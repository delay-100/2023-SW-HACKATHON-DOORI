제 21장
데이타베이스회복프로토콜의개요
Fundamentals of Database Systems
R. A. Elmasri and S. B. Navathe
© 2005 황규영 홍의경 음두헌 박영철 김진호 조완섭
2022-05-27 2Fundamentals of Database Systems
20.1 회복 개념
20.2 지연갱신을 기반으로 한 회복 기법
20.3 즉시갱신을 기반으로 한 회복 기법
20.4 그림자 페이지 기법
20.5 ARIES 회복 알고리즘
20.6 다중 데이타베이스에서의 회복
20.7 데이타베이스 백업과 재해적 실패로부터의 회복
목차
2022-05-27 3Fundamentals of Database Systems
20.1회복개념
20.1.1 회복 개요 및 회복 알고리즘의 분류
20.1.2 디스크 블록의 캐슁
20.1.3 로그 우선 출력, Steal/No-Steal, Force/No-Force
20.1.4 시스템 로그에서 검사점과 퍼지 검사점 기록
20.1.5 트랜잭션 복귀
2022-05-27 4Fundamentals of Database Systems
20.1.1회복개요및회복알고리즘의분류
l 회복이란 ? 
– 데이타베이스를 최근의 (가장 가까운 과거의) 일관된 상태로 복원하는 것
– 이렇게 하기 위해서 시스템은 트랜잭션이 실행되는 동안 데이타 항목의
변경에 대한 정보를 계속 유지하고 있어야 함
l 회복을 위한 전형적인 전략
– 재해적 실패에 대한 회복
• 데이타베이스 백업 (제 20.7 절 참조)
– 비재해적 실패에 대한 회복
• 지연갱신 기법 (제 20.2 절 참조)
– 지연갱신: 트랜잭션이 성공적으로 완료 시점에 이를 때까지
데이타베이스의 실제 갱신 연산을 연기한다.
• 즉시갱신 기법 (제 20.3 절 참조)
– 즉시갱신: 트랜잭션이 갱신 명령을 내리는 순간 데이타베이스를 갱신한다.
2022-05-27 5Fundamentals of Database Systems
l 디스크 페이지(블록) 캐슁
– 회복 처리는 주기억장치에 디스크 페이지들을 버퍼링하고 캐슁하는
것과 밀접한 관련이 있음
n DBMS 캐쉬와 캐쉬 디렉토리
– DBMS 캐쉬
• 데이타베이스 항목들을 주기억장치에 유지시키기 한 주기억장치 버퍼들의
집합
• 이 캐쉬는 운영체제가 아니라 DBMS가 관리함
– 캐쉬 디렉토리
• 데이타베이스 항목들이 버퍼 안에 있는지를 관리하기 위해 사용하는 <항목
이름, dirty-bit, 버퍼 위치> 엔트리들로 구성된 표
– DBMS가 데이타베이스 항목에 대한 동작을 요청하면
• 이미 캐쉬 안에 그 항목이 있는지 확인하기 위하여 캐쉬 디렉토리를 검사함
• 만약 그 항목이 캐쉬 안에 있으면 디스크 페이지를 가져올 필요가 없으며,
없으면 해당 디스크 페이지를 캐쉬 안으로 복사함
20.1.2디스크블록의캐슁
2022-05-27 6Fundamentals of Database Systems
– 버퍼 플러쉬
• 새로운 항목의 수용을 위한 공간을 마련하기 위하여 캐쉬 버퍼 중 일부를
플러쉬할 필요가 있음
• 버퍼를 플러쉬할 때 오손 비트가 세트된 버퍼만 디스크에 기록함
• 플러쉬 할 버퍼의 선택: 페이지 교체 전략(예: LRU, FIFO) 을 사용함
l 수정된 데이타 항목의 플러쉬 전략
– 즉시갱신 (in-place update)
• 갱신 이후값(after image)을 갱신 이전값(before image)이 위치한 곳에
덮어쓴다.
• 회복을 위하여 반드시 로그가 필요하다.
• 로그 우선 출력 기법(Write Ahead Logging: WAL)을 사용한다.
– 그림자 갱신(shadowing)
• 갱신 후의 값을 디스크의 다른 위치에 기록한다.
• 디스크에 어떤 데이타 항목에 대한 여러개의 사본이 존재할 수 있다.
20.1.2디스크블록의캐슁
2022-05-27 7Fundamentals of Database Systems
l 로그 우선 출력 기법
– 디스크 상의 항목의 이전값을 이후값으로 덮어쓰기 전에 데이타 항목의 이전
값을 포함하는 로그 엔트리가 디스크로 강제 출력되는 것을 보장하는 방식
– 트랜잭션을 위한 모든 REDO 유형과 UNDO 유형 로그 기록들이 디스크로 강제
출력된 후에야 트랜잭션이 완료될 수 있음
l 캐쉬에 있는 database의 페이지가 언제 디스크에 기록될 것인가?
– Steal/No-Steal 방식
• Steal 방식: 트랜잭션이 완료하기 전에 그 트랜잭션에 갱신된 캐쉬 페이지를
디스크에 기록할 수 있다.
• No-Steal 방식: 트랜잭션이 완료될 때까지 그 트랜잭션에 의해 갱신된 캐쉬
페이지를 디스크에 기록할 수 없다.
– Force/No-Force 방식
• Force 방식: 트랜잭션이 완료할 때에 그 트랜잭션에 의해 갱신된 캐쉬
페이지를 즉시 디스크에 기록하는 방식을 Force 방식, 그렇지 않은 방식을
No-Force 방식이라고 함
– 전형적인 데이타베이스 시스템들은 steal/no-force 방식을 사용함
20.1.3 로그우선출력, Steal/No-Steal, Force/No-Force
2022-05-27 8Fundamentals of Database Systems
l 검사점
– 주기적으로 모든 DBMS 버퍼에 있는 갱신된 데이타를 디스크에 기록하는 작업
– 검사점을 기록하기 전에 완료된 모든 트랜잭션의 갱신은 검사점 시점에서 모두
디스크에 반영되므로 그 이후 시스템 붕괴가 발생하더라도 REDO될 필요가 없음
– 따라서 검사점은 REDO해야 할 트랜잭션의 수를 줄여줌
l 검사점 기록 작업
1. 트랜잭션의 수행을 일시 정지 시킨다.
2. 갱신된 모든 버퍼를 강제로 디스크에 기록한다.
3. [검사점] 레코드를 로그에 기록하고, 그 로그를 강제로 디스크에 기록한다.
4. 트랜잭션의 수행을 계속시킨다.
l 퍼지 검사점
– 트랜잭션의 지연수행을 해결하기 위하여 모든 버퍼가 디스크에 기록되기를
기다리지 않고 [검사점] 레코드를 로그에 기록한 후 트랜잭션의 수행을 재개하는
방식
20.1.4 시스템로그에서검사점과퍼지검사점기록
2022-05-27 9Fundamentals of Database Systems
l 트랜잭션이 어떤 이유로 복귀되면 그 트랜잭션에 의해 변경된 모든
데이타 항목 값은 그 이전 값으로 되돌려져야 함
l 연쇄 복귀(Cascading rollback)
– 어떤 트랜잭션이 복귀됨에 따라 그 트랜잭션이 변경한 데이타 항목
값을 읽은 다른 트랜잭션들을 연쇄적으로 복귀해야 하는 현상
• 연쇄 복귀는 회복 프로토콜이 회복가능 스케줄을 보장하지만 엄격한 스케줄,
즉 비연쇄 스케줄을 보장하지 않을 때 발생할 수 있음
– 연쇄 복귀는 시간이 많이 걸리므로 대부분의 회복 메카니즘은 연쇄
복귀가 필요치 않도록 설계함
– 연쇄 복귀를 허용하는 회복 기법의 경우 트랜잭션의 연쇄 복귀를
결정하기 위해 read_item 연산들이 시스템 로그에 기록되어야 함
20.1.5트랜잭션복귀
2022-05-27 10Fundamentals of Database Systems
(a)세트랜잭션들의읽기/쓰기연산
[그림 20.1] 연쇄복귀
read_item(A)
read_item(D)
write_item(D)
read_item(B)
write_item(B)
read_item(D)
write_item(D)
read_item(C)
write_item(B)
read_item(A)
write_item(A)
T1 T2 T3
초기값: A = 30, B = 15, C = 40, D = 20
(a)
2022-05-27 11Fundamentals of Database Systems
A B C D      
[start-transaction, T3] 30 15 40 20
[read_item, T3, C]
* [write_item, T3, B, 15, 12] 12
[start-transaction, T2]
[read_item, T2, B]
** [write_item, T2, B, 12, 18] 18
[start-transaction, T1]
[read_item, T1, A]
[read_item, T1, D]
[write_item, T1, D, 20, 25] 25
[read_item, T2, D]
** [write_item, T2, D, 25,26] 26
[read_item, T3, A]
 시스템붕괴(system crash)
* T3는완료점에이르지못했기때문에복귀된다.
** T2는 T3에의해변경된값 B를읽었기때문에복귀된다.
(b)붕괴시의시스템 로그
[그림 20.1] 연쇄복귀 (cont.)
(b)
2022-05-27 12Fundamentals of Database Systems
(c)붕괴전의연산들
[그림 20.1]연쇄복귀 (cont.)
시간
시스템붕괴
BEGIN
READ(C) WRITE(B)
BEGIN
BEGIN
READ(A)
READ(B) READ(D)
READ(A)READ(D)
WRITE(B) WRITE(D)
WRITE(D)
T3
T2
T1
(c)
2022-05-27 13Fundamentals of Database Systems
20.2 지연갱신을기반으로한회복기법
l 지연갱신 기법
– 트랜잭션이 성공적으로 완료 시점에 이를 때까지 데이타베이스에
대한 실제 갱신 연산을 연기하는 방식
– 트랜잭션이 실행되는 동안, 갱신되는 내용은 단지 로그와 캐쉬
버퍼에만 기록됨
– 각 트랜잭션이 짧고 적은 수의 항목을 갱신하는 경우에만 사용 가능함
– No-Steal 방식
– NO-UNDO/REDO 알고리즘
l 지연갱신 프로토콜
1. 트랜잭션은 완료점에 이르기 전까지는 데이타베이스를 변경시킬 수
없다.
2. 트랜잭션은 트랜잭션의 모든 갱신 연산들이 로그에 기록되고
로그에서 디스크로 강제 출력되기 전까지는 완료점에 이를 수 없다.
2022-05-27 14Fundamentals of Database Systems
l RDU_S(Recovery using Deferred Update in a Single-user 
environment)
– 두개의 트랜잭션 리스트를 사용한다.
• 검사점 이후에 완료된 트랜잭션 리스트 T
• 진행 중인 트랜잭션 리스트: 단일 사용자 환경이므로 최대 1개
– T의 모든 write_item연산들에 대하여 로그에 기록된 순서대로 REDO한
후 진행 중인 트랜잭션을 다시 시작한다.
l REDO(WRITE_OP)
– WRITE_OP에 대응되는 로그 엔트리 [write_item, T, X, new_value]를
검사하고, 데이타베이스의 X 값을 new_value로 설정한다.
l REDO 연산의 멱득성(idempotence)
– REDO연산을 반복 수행해도 단 한번 수행하는 것과 동일하다는 성질
l 회복 처리 전체의 멱득성
– 회복 도중에 붕괴되어 회복한 결과는 회복 도중에 붕괴된 적이 없는
회복의 결과와 같아야 한다
20.2.1 단일사용자환경에서지연갱신을사용한회복
2022-05-27 15Fundamentals of Database Systems
[그림 20.2] 단일사용자환경에서지연갱신을사용한복귀
(a)두트랜잭션들의읽기와 쓰기연산들
(b)붕괴시의시스템로그
[start-transaction, T1]
[write_item,T1,D,20]
[commit,T1]
[start-transaction,T2]
[write_item,T2,B,10]
[write_item,T2,D,25]       시스템붕괴
T1의 [write-item, ...]연산들은 REDO된다.
T2의로그엔트리들은회복처리가무시한다.
     T1
read_item(A)
read_item(D)
write_item(D)
     T2
read_item(B)
write_item(B)
read_item(D)
write_item(D)
(a)
(b)
2022-05-27 16Fundamentals of Database Systems
l 동시성 제어 방법에 대한 가정
– 2단계 로킹을 사용하여 동시성을 제어한다.
– 트랜잭션 수행이 시작되기 전에 트랜잭션에서 필요한 모든 항목들에
대한 로크를 미리 획득하여 교착 상태를 방지한다.
l RDU_M(Recovery using Deferred Update in a Multiuser
environment)
– 두개의 트랜잭션 리스트 사용한다.
• 검사점 이후에 완료된 트랜잭션 리스트 T
• 진행 중인 트랜잭션 리스트 T’
– T의 모든 write_item 연산들에 대하여 로그에 기록된 순서대로 REDO한
후 T’은 처음부터 다시 실행되어야 한다.
20.2.2 다수사용자시스템에서동시에수행되는
환경에서의지연갱신
2022-05-27 17Fundamentals of Database Systems
20.2.2 다수사용자시스템에서동시에수행되는
환경에서의지연갱신(cont.)
l RDU_M 알고리즘의개선
–로그의끝(시스템이붕괴된시점)에서부터시작하여어떤항목이
REDO될때마다그항목을 REDO된항목들의리스트에추가한다.
– REDO 된항목들의리스트에있는항목은최근값이이미
회복되었으므로 REDO를적용하지않는다.
2022-05-27 18Fundamentals of Database Systems
검사점
(checkpoint)
시스템붕괴
(system crash)
t1 t2
T1
T2
T3
T4
T5
시간
[그림 20.3]동시에실행되는 트랜잭션들의한스케쥴
2022-05-27 19Fundamentals of Database Systems
[start_transaction, T1]
[write_item, T1, D, 20]
[commit, T1]
[checkpoint]
[start_transaction, T4]
[write_item, T4, B, 15]
[write_item, T4, A, 20]
[commit, T4]
[start_transaction, T2]
[write_item, T2, B, 12]
[start_transaction, T3]
[write_item, T3, A, 30]
[write_item, T2, D, 25]
read_item(A)
read_item(D)
write_item(D)
T1
read_item(B)
write_item(B)
read_item(D)
write_item(D)
T2
read_item(A)
write_item(A)
read_item(C)
write_item(C)
T3
read_item(B)
write_item(B)
read_item(A)
write_item(A)
T4
(a)
(b)
시스템붕괴
T2와 T3은완료점에이르지못했기때문에
무시한다.
T4는마지막검사점이후에완료되었기
때문에 REDO한다.
[그림 20.4] 동시에수행되는트랜잭션들에지연갱신을사용한회복
    (a) 네트랜잭션의읽기와쓰기연산들
    (b)붕괴시의시스템로그
2022-05-27 20Fundamentals of Database Systems
• 데이타베이스에 영향을 끼치지 않는 연산들의 처리
예) 데이타베이스에서 검색한 정보로부터 메시지나 보고서를
만들어
인쇄하는 작업
– 트랜잭션이완료시점에이른후에일괄작업으로수행한다.
– 트랜잭션이실패하면이일괄작업은취소된다.
 20.2.3데이타베이스에영향을끼치지않는
트랜잭션연산
2022-05-27 21Fundamentals of Database Systems
20.3 즉시갱신을기반으로한회복기법
• 즉시갱신기법
–트랜잭션이갱신명령을내리는순간데이타베이스갱신함
–실패하는시점에서실행중이던트랜잭션에대하여 UNDO 연산이필요함
– WAL 방식을이용함
–종류
• UNDO/NO-REDO : 트랜잭션이완료되기전에그트랜잭션의모든갱신이
디스크에반영되는경우
• UNDO/REDO :  모든갱신이디스크에반영되기전에트랜잭션이완료할수
있는경우
• 이절의내용
20.3.1단일사용자환경에서즉시갱신에기반을둔 UNDO/REDO 
회복기법
20.3.2동시에수행되는환경에서즉시갱신의 UNDO/REDO
2022-05-27 22Fundamentals of Database Systems
• RIU_S(Recovery using Immediate Update in a Single-user
environment)
– 두개의 트랜잭션 리스트 사용한다.
• 검사점 이후에 완료된 트랜잭션 리스트 T
• 진행 중인 트랜잭션 리스트: 단일 사용자 환경이므로 최대 1개
– 진행 중인 트랜잭션의 모든 write_item 연산들을 UNDO한다.
– T의 모든 write_item연산들에 대하여 로그 기록 순서대로 REDO 한다.
• UNDO(WRITE_OP)
– WRITE_OP에 대응되는 로그 엔트리 [write_item, T, X, new_value]를
검사하고, 데이타베이스의 X 값을 old_value로 설정한다.
– 다수의 write_item 연산을 UNDO할 때에는 로그에 기록된 순서의
역순으로 UNDO 한다.
20.3.1단일사용자환경에서즉시갱신에
기반을둔 UNDO/REDO회복기법
2022-05-27 23Fundamentals of Database Systems
• 동시성 제어 방법에 대한 가정
– 동시성 제어 프로토콜이 엄격한 2단계 로킹 프로토콜처럼 엄격한
스케줄을 만들고 교착 상태가 발생할 수 있는 시스템을 가정한다.
• RIU_M(Recovery using Immediate Update in a Multiuser
environment)
– 두개의 트랜잭션 리스트 사용한다.
• 검사점 이후에 완료된 트랜잭션 리스트 T
• 진행 중인 트랜잭션 리스트: T’
– T’의 모든 write_item 연산들을 로그에 기록된 연순으로 UNDO한다.
– T의 모든 write_item연산들에 대하여 로그에 기록된 순서대로 REDO
한다.
20.3.2동시에수행되는환경에서
즉시갱신의 UNDO/REDO
2022-05-27 24Fundamentals of Database Systems
20.4 그림자페이지기법
• 가정
– 데이타베이스: 여러개(N)의 고정된 크기의 디스크 페이지들로 구성된다.
– 디렉토리: i (1 < i < N)번째 엔트리는 i번째 데이타베이스 페이지를 가리킨다.
– 데이타베이스에 대한 모든 읽기, 쓰기 연산은 디렉토리를 통하여 이루어진다.
• 트랜잭션 수행 방법
1. 트랜잭션이 시작할 때: 현재 디렉토리를 그림자 디렉토리로 복사한다.
2. write_item연산을 수행할 때: 수정된 데이타베이스 페이지의 새 사본을
생성하고, 현재 디렉토리 엔트리가 새 사본을 가리키도록 수정한다.
3. 트랜잭션을 완료할 때: 그림자 디렉토리를 폐기하고 그 그림자 디렉토리가
참조하는 이전 페이지들을 반환한다.
• 트랜잭션 복귀 방법
1. 수정된 데이타베이스 페이지를 반환하고, 현재의 디렉토리를 폐기한다.
2. 그림자 디렉토리를 현재 디렉토리로 설정한다.
2022-05-27 25Fundamentals of Database Systems
• 특징
– 단일 사용자 환경에서 로그가 불필요하다.
– 다사용자 환경에서는 동시성 제어 기법에 로그가 필요한 경우 회복
기법에서도 로그가 필요할 수 있다.
• 예: System R은 검사점, 로깅과 함께 그림자 페이징을 이용
– NO-UNDO/NO-REDO 기법
– 장점
• 트랜잭션 실행 결과의 UNDO가 간단하다.
– 단점
• 갱신된 데이타베이스 페이지들의 디스크 상의 위치가 변하기 때문에
클러스터링이 어렵다.
• 디렉토리가 큰 경우 오버헤드가 심각하다.
• 트랜잭션 완료시 쓰레기를 수거해야 하는 문제가 있다.
20.4 그림자페이지기법
2022-05-27 26Fundamentals of Database Systems
[그림 20.5]그림자페이지기법
페이지 5
(이전페이지
페이지 1
페이지 4
페이지 2
(이전페이지)
페이지 3
페이지 6
페이지 2
(새페이지)
페이지 5
(새페이지)
1
2
3
4
5
6
1
2
3
4
5
6
현재디렉토리
(갱신한후)
데이타베이스디스크블록(페이지)들
그림자디렉토리
(갱신되지않음)
2022-05-27 27Fundamentals of Database Systems
• 기본 개념
– WAL 사용
– REDO 중 역사 반복(repeating history): 붕괴가 발생했을 때의
데이타베이스 상태를 복구하기 위하여 붕괴 발생 이전에 수행했던 모든
연산을 다시 한번 수행한다. 붕괴가 발생했을 때 완료되지 않은
상태였던 트랜잭션(진행 트랜잭션)은 UNDO된다.
– UNDO 중 로깅: UNDO를 할 때에도 로깅을 함으로써 회복을 수행하는
도중에 실패하여 회복을 다시 시작할 때에 이미 완료된 UNDO 연산은
반복하지 않는다.
• 주요 3단계
– 분석 단계
– REDO 단계
– UNDO 단계
20.5 ARIES 회복알고리즘
2022-05-27 28Fundamentals of Database Systems
• 분석 단계
– 붕괴가 발생한 시점에 버퍼에 있는 수정된 페이지와 진행 트랜잭션을
파악한다.
– REDO가 시작되어야 하는 로그의 위치를 결정한다.
• REDO 단계
– 분석 단계에서 결정한 REDO 시작 위치의 로그로부터 로그가 끝날
때까지 REDO를 수행한다.
– REDO 된 로그 레코드의 리스트를 관리하여 불 필요한 REDO연산이
수행되지 않도록 한다.
• UNDO 단계
– 로그를 역순으로 읽으면서 진행 트랜잭션의 연산을 역순으로
UNDO한다.
20.5 ARIES 회복알고리즘(cont.)
2022-05-27 29Fundamentals of Database Systems
• 회복을 위해 필요한 정보
– 로그
• 페이지에 대한 갱신(write), 트랜잭션 완료(commit), 트랜잭션 철회(abort),
갱신에 대한 UNDO, 트랜잭션 종료(end) 시 기록된다.
• 각 로그레코드마다 로그 순차번호(LSN)가 할당된다.
• LSN(Log Sequence Number): 디스크에 저장된 로그 레코드의 주소로서
단조 증가한다.
– 트랜잭션 테이블
• 진행 트랜잭션에 대한 정보(트랜잭션 식별자, 트랜잭션 상태, 해당
트랜잭션의 가장 최근 로그레코드의 LSN)가 관리된다.
– 오손 페이지 테이블
• 버퍼에 있는 오손 페이지에 대한 정보(페이지 식별자, 해당 페이지에 대한
가장 최근 로그 레코드의 LSN)가 관리된다.
20.5 ARIES 회복알고리즘(cont.)
2022-05-27 30Fundamentals of Database Systems
• ARIES에서의 검사점 기록
1. 로그에 begin_checkpoint 레코드를 기록하기
2. 로그에 end_checkpoint 레코드를 기록하기
트랜잭션 테이블과 오손 페이지 테이블의 내용도 함께 저장한다.
3. 특수 화일에 begin_checkpoint 레코드의 LSN을 기록하기
20.5 ARIES 회복알고리즘(cont.)
2022-05-27 31Fundamentals of Database Systems
LSN     LAST_LSN TRAN_ID  TYPE PAGE_ID OTHER INFORMATION
1 0 T1 update C ......
 2             0                 T2      update            B                  ......
 3             1                 T1      commit                             ......
 4    begin checkpoint
 5     end checkpoint
6 0 T3 update A ......
 7             2                 T2      update            C                  ......
 8             7                 T2      commit                             ......
(a)
[그림 20.6] ARIES에서회복의예
 (a) 붕괴시의로그
2022-05-27 32Fundamentals of Database Systems
[그림 20.6] ARIES에서회복의예
(b)검사점을기록할때의트랜잭션테이블과오손페이지테이블
                 (c) 분석단계가끝난후의트랜잭션테이블과오손페이지테이블
TRANSACTION TABLE DIRTY PAGE TABLE
TRAN_ID   LAST LSN    STATUS                  PAGE_ID LSN
    T1                3           commit                        C               1
    T2                2           in progress                     B               2
(b)
    TRANSACTION TABLE                           DIRTY PAGE TABLE
TRAN_ID LAST LSN STATUS PAGE_ID LSN
    T1                3          commit                         C               1
    T2                8          commit                         B               2
T3 6 in progress A 6
(c)
2022-05-27 33Fundamentals of Database Systems
• 다중 데이타베이스 트랜잭션
– 여러개의 데이타베이스를 액세스하는 트랜잭션으로 이 때 각각의
DBMS들은 서로 다른 회복 기법과 트랜잭션 관리자를 사용할 수 있다.
– 원자성을 유지하기 위하여 2 단계 완료 프로토콜을 사용한다.
• 모든 참여 데이타베이스가 트랜잭션을 완료하도록 하거나 또는 어느
하나도 완료하지 않도록 한다.
• 어떤 참여 데이타베이스에 고장이 발생하더라도 트랜잭션이 완료된 상태
또는 철회된 상태로의 회복은 항상 가능하다.
20.6  다중데이타베이스에서의회복
2022-05-27 34Fundamentals of Database Systems
• 2단계완료프로토콜(two-phase commit protocol)
– 1단계
– 2단계:모든참여데이타베이스가 “완료준비”되었으면조정자는 “완료”
신호를보낸다.하나이상의참여데이타베이스가 “완료불가”신호를
보내면조정자는 “철회” 신호를보낸다.
조정자
참여데이타베이스
참여데이타베이스
참여데이타베이스
k완료 준비또는 완료불가
j완료 예정
조정자
참여데이타베이스
참여데이타베이스
참여데이타베이스
완료 또는철회
20.6 다중데이타베이스에서의회복
2022-05-27 35Fundamentals of Database Systems
20.7  데이타베이스백업과재해로부터의회복
• 백업
– 전체 데이타베이스와 로그를 정기적으로 값싼 기억장치에 복사한다.
• 시스템 로그는 자주 백업한다.
– 데이타베이스보다 크기가 작으므로 자주 백업하는 것이 가능하다.
– 마지막 데이타베이스 백업 이후에 완료된 트랜잭션의 결과를 회복할
때 시스템 로그가 사용된다.
• 데이타베이스 백업 후에는 시스템 로그를 새로 시작한다.
– 디스크 실패로부터의 회복 방법
1. 최근 데이타베이스 백업 사본으로 데이타베이스를 디스크에 재구성 한다.
2. 시스템 로그의 백업 사본에 기록된 완료된 모든 트랜잭션의 연산들의
효과를 재구성된 데이타베이스에 반영한다.
2022-05-27 36Fundamentals of Database Systems
l 회복의 개념 소개
– 로그우선 출력과 검사점
l 회복 기법들
– 지연갱신을 기반으로 한 회복 기법
– 즉시갱신을 기반으로 한 회복 기법
– 그림자 페이지 기법
l 상용 기법
– ARIES 회복 알고리즘
l 다중 데이타베이스에서의 회복
l 재해로부터의 회복
– 데이타베이스 백업을 기반으로 함
요  약
